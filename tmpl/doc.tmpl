<h2>dejavu</h2>
<p>Have you ever had the feeling that you&#39;re seeing something you&#39;ve already seen
before? That&#39;s the feeling you get when using <code>dejavu</code>.

</p>
<p>If you are a developer coming from a language like PHP, Java, ActionScript 3.0,
and others, it&#39;s likely that you are already familiar with Object Oriented
Programming. However, JavaScript uses prototypal inheritance which, although
powerful and flexible, can be difficult to understand, and specially to maintain
in large projects.

</p>
<p><code>dejavu</code> is a library that delivers classical inheritance on top of JavaScript
prototypal inheritance, making it a breeze to move into JavaScript.



</p>
<h2>Why another?</h2>
<p>There are some libraries out there able to shim classical inheritance,
however none offers all the functionality that many programmers require.

</p>
<p>Also, even though being one of the most feature rich OOP libraries out there, it has an outstanding performance, rivaling with vanilla in production.



</p>
<h2>Features</h2>
<ul>
<li>Classes (concrete, abstract and final)</li>
<li>Interfaces</li>
<li>Mixins (so you can get some sort of multiple inheritance)</li>
<li>Private and protected members</li>
<li>Static members</li>
<li>Constants</li>
<li>Context binding for functions</li>
<li>Method signature checks</li>
<li>Possible to extend or borrow from vanilla classes</li>
<li>Custom instanceOf with support for Interfaces</li>
<li>Two builds, <code>regular</code> and <code>AMD</code> based<ul>
<li><code>AMD</code> optimized for speeding up developer workflow, allowing testing
without the need to re-compile everything into a single file</li>
<li><code>regular</code> if you are not using <code>AMD</code> in your projects</li>
</ul>
</li>
<li>Two modes for each build, <code>strict</code> and <code>loose</code><ul>
<li><code>strict</code> best in development, enforcing a lot of checks, making sure you
don&#39;t make many typical mistakes</li>
<li><code>loose</code> best for production, without checks, improving performance</li>
</ul>
</li>
</ul>
<p>Users are encouraged to declare
<a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">&#39;use strict&#39;</a> while
using the <code>dejavu</code> in strict mode, otherwise some code might fail silently.
This can happen because <code>dejavu</code> uses <code>Object.freeze</code> and <code>Object.seal</code> to lock
classes and instances, guaranteeing that no one changes the behaviour of your
classes by replacing methods, etc, and possibly breaking your code, making it
really hard to pin point what&#39;s wrong. Although this is the default behaviour, it can be changed.

</p>
<p>You will read more on it later in this document.

</p>
<p><strong>Do not confuse &#39;use strict&#39; with the dejavu strict mode.</strong>



</p>
<h2>Getting started</h2>
<p>The quickest way to start using <code>dejavu</code> in your project, is by simply including
<code>dist/regular/strict/dejavu.js</code> (note that this is in <strong>strict</strong> mode).

</p>
<p>If you&#39;re developing a <strong>client-side</strong> app, simply put the file in some folder,
and include it in the HTML:

</p>
<pre><code class="lang-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;Content-Type&quot;
              content=&quot;text/html; charset=UTF-8&quot;&gt;
        &lt;script type=&quot;text/javascript&quot; src=&quot;dejavu.js&quot;&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
            &#39;use strict&#39;;

            // declare the &quot;Person&quot; class
            var Person = dejavu.Class.declare({
                _name: null,

                initialize: function(name) {
                    this.setName(name);
                },

                setName: function(name) {
                    this._name = name;

                    return this;
                },

                getName: function() {
                    return this._name;
                }
            });

            // create a new instance of person
            var indigo = new Person(&#39;Marco&#39;);
            console.log(&#39;A new indigo was born,&#39;, indigo.getName());
        &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>This will make a <code>dejavu</code> global available for you.
If you&#39;re developing in <strong>Node.js</strong>, install it with <code>npm install dejavu</code> and use it like so:

</p>
<pre><code class="lang-js">var dejavu = require(&#39;dejavu&#39;);

// declare the &quot;Person&quot; class
var Person = dejavu.Class.declare({
    _name: null,

    initialize: function(name) {
        this.setName(name);
    },

    setName: function(name) {
        this._name = name;

        return this;
    },

    getName: function() {
        return this._name;
    }
});

// create a new instance of person
var indigo = new Person(&quot;Marco&quot;);
console.log(&quot;A new indigo was born,&quot;, indigo.getName());</code></pre>
<p>The installation will create a <code>.dejavurc</code> in your package, where you can enable/disable the strict mode as well as change other dejavu options.
By default the strict mode is used. Still, you want to leverage your package with the loose mode.
Because dejavu reads<code>.dejavurc</code> from the process.cwd(), packages that require your package will be running the loose mode unless they also define a <code>.dejavurc</code> (which will only happen if they also depend on dejavu directly).



</p>
<h2>Benchmarks</h2>
<p>You can run the <a href="http://jsperf.com/oop-benchmark/107">benchmark</a> yourself. Note that the benchmark below compares dejavu with libraries that do not provide many of the features that dejavu does. For more details, please consult the libraries documentation.

</p>
<p>It is also important to mention that some libraries like <a href="https://github.com/tnhu/jsface">JSFace</a> does not chain prototypes. This gives them an extra edge in performance in some browsers, like Firefox, but renders the <code>instanceof</code> operator useless.

</p>
<p>{{graph}}

</p>
<h3>Mobile</h3>
<p>{{graph_mobile}}



</p>
<h2>Performance</h2>
<p>Since all those nice features and common rules of classic OOP degrade
performance, <code>dejavu</code> has two separates modes, for different stages in the
development.

</p>
<p>The <code>strict</code> mode is suitable for <strong>development</strong>, and will do all sorts of
checks, throwing an error when you try to do something considered illegal.

</p>
<p><strong>Note that if your project works in strict mode, it will work in loose mode.</strong>

</p>
<p>As for the <code>loose</code> mode, there is no overhead associated with checks, thus
making it suitable for <strong>production</strong>, since it will be more efficient and
have a <strong>lower memory footprint and filesize</strong>.

</p>
<p>Finally, in order to achieve that extra edge, that puts <code>dejavu</code> next to vanilla
JS in terms of performance, you should run the optimizer that is bundled with
the library. Note that this step is completely optional, and <code>dejavu</code> will still
perform faster than most libraries, even if you don&#39;t run the <a href="https://github.com/IndigoUnited/dejavu##optimizer">optimizer</a>.
The optimizer will analyse your code and make some improvements,
boosting it a bit further.

</p>
<p>You can check the benchmarks in <a href="http://jsperf.com/oop-benchmark/79">jsperf</a>
comparing <code>dejavu</code> with other OOP libraries. Note that the loose mode
is used in this test, simulating a production environment, and both the normal
and optimized versions are tested.



</p>
<h2>Syntax</h2>
<h3>Overview</h3>
<p>Here&#39;s an overview of what most developers look for in an OOP library. You can find complete examples further down.

</p>
<pre><code class="lang-js">var Person = Class.declare({
    // although not mandatory, it&#39;s really useful to identify
    // the class name, which simplifies debugging
    $name: &#39;Person&#39;,

    // this is a protected property, which is identified by
    // the single underscore. two underscores denotes a
    // private property, and no underscore stands for public
    _name: null,
    __pinCode: null,

    // class constructor
    initialize: function (name, pinCode) {
        this._name = name;
        this.__pinCode = pinCode;

        // note that we&#39;re binding to the current instance in this case.
        // also note that if this function is to be used only as a
        // callback, you can use $bound(), which will be more efficient
        setTimeout(this._logName.$bind(this), 1000);
    },

    // public method (follows the same visibility logic, in this case
    // with no underscore)
    getName: function () {
        return this._name;
    }

    _logName: function () {
        console.log(this._name);
    }
});</code></pre>
<h3>Complete example</h3>
<p>For those looking for something more, here&#39;s a more complete usage of <code>dejavu</code>.

</p>
<p>This example illustrates the usage of:

</p>
<ul>
<li><code>$name</code> meta attribute</li>
<li><code>this.$self</code> vs <code>this.$static</code></li>
<li><code>$super()</code> for accessing overridden methods</li>
<li><code>instanceOf</code></li>
<li>member visibility</li>
<li>statics, abstracts, abstract statics, finals, final statics and constants</li>
<li><code>$extends</code> vs <code>$borrows</code></li>
<li>binding (<code>$bind()</code> vs <code>$bound()</code>)</li>
</ul>
<p>In this case, and keep in mind that this is just for illustration purposes, we&#39;ll create three interfaces, that are implemented by an abstract class, that is then extended by a concrete class.


</p>
<pre><code class="lang-js">var dejavu = require(&#39;dejavu&#39;);

// ------------ AN INTERFACE ------------
// this interface is useless, is only here to illustrate
// that interfaces can extend other interfaces
var UselessInterface = dejavu.Interface.declare({
    $name: &#39;UselessInterface&#39;
});

var PersonInterface = dejavu.Interface.declare({
    $name: &#39;PersonInterface&#39;,
    // if you need to extend multiple interfaces,
    // just provide an array
    $extends: UselessInterface,

    // interface methods can specify argument list, and any class
    // that implements that interface will be automatically checked,
    // to make sure it obeys the method signature. If you want to
    // specify an optional argument, you should prepend it by a dollar
    // sign, like so: someMethod(arg1, arg2, $thisArgIsOptional)
    getName: function () {},
    setName: function (name) {}
});

// ------------ ANOTHER INTERFACE ------------
var EngineerInterface = dejavu.Interface.declare({
    $name: &#39;EngineerInterface&#39;,

    think: function(subject) {}
});

// ------------ AN ABSTRACT CLASS ------------
var AbstractIndigo = dejavu.AbstractClass.declare({
    $name: &#39;AbstractIndigo&#39;,
    // implements multiple interfaces
    $implements: [PersonInterface, EngineerInterface],

    $constants: {
        INDIGO_WEBSITE: &#39;http://www.indigounited.com/&#39;,
        INDIGO_EMAIL:   &#39;hello@indigounited.com&#39;
    },

    $statics: {
        logIndigoInfo: function () {
            // by using this.$static, we&#39;re making sure that dejavu
            // uses late binding to resolve the member. If you&#39;re
            // looking for early binding, you can use this.$self
            // instead
            console.log(
                this.$static.INDIGO_WEBSITE,
                this.$static.INDIGO_EMAIL
            );
        }
    },

    // method/attribute visibility is controlled by
    // the number of underscores that the identifier
    // has:
    // public:    no underscores
    // protected: 1 underscore
    // private:   2 underscores
    //
    // the attribute below is protected
    _name: null,

    getName: function () {
        return this._name;
    },

    setName: function (name) {
        this._name = name;

        return this;
    },

    // note that we&#39;re not implementing the method `think()` of the
    // EngineerInterface. This will be automatically turned into an
    // abstract method, since we&#39;re in an abstract class
    $abstracts: {
        beAwesome: function () {}

        // you can also put &quot;$statics {}&quot; here
        // to create an abstract static method
    },

    // finals are not overridable
    $finals: {
        // you can also put &quot;$statics {}&quot; here
        // to create a final static method

        thisIsFinal: function () {
            console.log(&#39;Can\&#39;t change this!&#39;);
        }
    }
});

// ------------ A CONCRETE CLASS ------------
// also, if you need this concrete class to be final,
// you can just use dejavu.FinalClass.declare instead
var Indigo = dejavu.Class.declare({
    $name: &#39;Indigo&#39;,
    // class extends another one.
    //
    // in case you need to extend from several classes,
    // you can instead use $borrows, and specify an
    // array of identifiers. Still, note that borrowing
    // will not allow you to perform dejavu.instanceOf
    // tests, as the class is not technically extending
    // the other, just borrowing its behaviour.
    $extends: AbstractIndigo,

    _subject: &#39;nothing&#39;,

    initialize: function (name) {
        // call the parent method, in this case the parent constructor,
        // but can be applied to any method when you need to call the
        // overridden method
        this.$super();

        this.setName(name);

        // note that we&#39;re binding the context to the current
        // instance. If, like in this case, the callback
        // function is to be used only as a callback, you
        // can just do .$bound(), upon declaring the function
        // which is equivalent to .$bind(this), but more efficient
        setInterval(this._logThought.$bind(this), 1000);
    },

    beAwesome: function () {
        console.log(this._name, &#39;is being awesome!&#39;);
        this.$self.logIndigoInfo();
        this.think(&#39;the next big thing&#39;);
    },

    think: function (subject) {
        this._subject = subject;
    },

    _logThought: function () {
        console.log(this._name, &#39;is thinking about&#39;, this._subject);
    }//.bound() would be equivalent to the binding in the constructor
});

var indigo = new Indigo(&#39;Andr√©&#39;);
indigo.beAwesome();

// check the type of an object
console.log(
    dejavu.instanceOf(indigo, EngineerInterface) ?
    &#39;we have an engineer!&#39;
    : &#39;say what now?&#39;
);
console.log(dejavu.instanceOf(indigo, Indigo) ?
    &#39;we have an indigo!&#39;
    : &#39;say what now?&#39;
);
// native instanceof also works for classes, but not for interfaces
console.log((indigo instanceof Indigo) ?
    &#39;we have an indigo!&#39;
    : &#39;say what now?&#39;
);</code></pre>
<h2>Taking it to another level</h2>
<p>Front-end devs are encouraged to program using the AMD paradigm because of its obvious benefits.
Since dejavu is built on it, it will integrate seamlessly with your AMD loader.
The easy way to set it up is to define a path for dejavu in your loader config like so:

</p>
<pre><code class="lang-js">{
   // your loader config
   paths: {
       // You can switch to the loose mode anytime
       &#39;dejavu&#39;: &#39;/path/to/dejavu/dist/strict/main&#39;,
       &#39;mout&#39;: &#39;../vendor/mout/src&#39;
   }
}</code></pre>
<p>Then require it and use it:

</p>
<pre><code class="lang-js">define([&#39;dejavu&#39;], function (dejavu) {

    // the dejavu variable is an object that contains:
    // Class
    // FinalClass
    // AbstractClass
    // Interface
    // instanceOf
    // options

    // example usage
    var Person = dejavu.Class.declare({
        initialize: function () {
            // ...
        }
    });

    return Person;
});</code></pre>
<p>If you just want to require specific parts of <code>dejavu</code>, you can do so.
In order to achieve this, you must configure your loader like so:


</p>
<pre><code class="lang-js">{
    // your loader config
    paths: {
           &#39;mout&#39;: &#39;../vendor/mout/src&#39;
    },
    packages: [
        {
            name: &#39;dejavu&#39;,
            // You can switch to the loose mode anytime
            location: &#39;/path/to/dejavu/dist/strict&#39;
        }
    ]
}</code></pre>
<p>With this setup, you can still require the dejavu object like shown above or require specific parts of it:

</p>
<pre><code class="lang-js">define([&#39;dejavu/Class&#39;], function (Class) {

    // Example usage
    var Person = dejavu.Class.declare({
        initialize: function () {
            // ...
        }
    });

    return MyClass;
});</code></pre>
<p>As you can see, in this case, only the <code>Class</code> module of <code>dejavu</code> is included,
which means all the other modules are not loaded.




</p>
<h2>Additional details</h2>
<h3>Classes/instances are locked</h3>
<p>By default, constructors and instances are locked. This means that no one can monkey patch your code.

</p>
<p>This behaviour can be changed in two ways:

</p>
<h4>With the $locked flag:</h4>
<pre><code class="lang-js">var UnlockedIndigo = Class.declare({
    $name: &#39;UnlockedIndigo&#39;,
    $locked: false

    initialize: function () {
        // Altough the foo property is not declared,
        // it will not throw an error

        this.name = &#39;Filipe&#39;;
    },

    talk: function () {
        console.log(&#39;An indigo is talking!&#39;);
    }
});</code></pre>
<p>Members can be added, replaced and deleted from the prototype:

</p>
<pre><code class="lang-js">UnlockedIndigo.prototype.age = 20;
UnlockedIndigo.prototype.talk = function () {
    console.log(&#39;... now is running&#39;);
};</code></pre>
<p>Members can be added, replaced and deleted from the instance:

</p>
<pre><code class="lang-js">var filipe     = new UnlockedIndigo();
filipe.friends = [&#39;Marco&#39;,&#39;Andre&#39;];
filipe.talk    = function () {
    console.log(&#39;I am talking about dejavu!&#39;);
};</code></pre>
<h4>By setting the global option:</h4>
<p>This will change the default behaviour, but classes can still override it with the $locked flag.

</p>
<pre><code class="lang-js">dejavu.options.locked = false;</code></pre>
<p>Note that once a class is unlocked, its subclasses cannot be locked.
Also, although undeclared members are allowed, they will not have their access controlled (they are interpreted as public).



</p>
<h3>Vanilla classes</h3>
<p><code>dejavu</code> allows you to extend or borrow vanilla classes. In this case, constructors and instances are forcibly UNLOCKED.

</p>
<pre><code class="lang-js">function Person(name) {
    this.name = name;
};

var Engineer = dejavu.Class.declare({
    $extends: Person
});

var filipe = new Engineer(&#39;Filipe&#39;);
// Engineer class and filipe instance are unlocked</code></pre>
<h3>Debugging</h3>
<p>In strict mode, logging instances with <code>console.log</code> will print some strange stuff (getters, setters, etc).
This happens because <code>dejavu</code> manages accesses to private/protected members as well as make other stuff work.
To get around this issue, <code>dejavu</code> provides a <code>console.inspect</code> method that works just like <code>console.log</code> but prints a friendly object representation of the instance.



</p>
<h2>Optimizer</h2>
<h2>Optimizer</h2>
<p><code>dejavu</code> bundles an optimizer that makes your code faster and lighter.

</p>
<p>It specifically:

</p>
<ul>
<li>Improves $super and $self usage</li>
<li>Removes all $name and $locked properties because they are not used in the loose version</li>
<li>Removes the need for wrappers, improving performance by a great margin</li>
<li>Removes abstract functions from abstract classes</li>
<li>Removes functions from interfaces</li>
</ul>
<p>The optimizer is located in the <code>bin</code> folder.
If you are optimizing your code for <code>nodejs</code> then pass the --closure option. This will boost the performance when running code in v8.
Please look at the jsperf results to see the difference in the different browsers.

</p>
<p>Example usage:

</p>
<p><code>node optimizer &lt; file_in.js &gt; file_out.js</code>

</p>
<p>You can also use the optimizer programatically, please check <code>bin/optimizer</code> for an example.

</p>
<p><code>dejavu</code> also comes with a automaton task.

</p>
<p>Below is a sample usage:

</p>
<pre><code class="lang-js">var dejavuOptimizer = require(&#39;dejavu/tasks/optimizer.autofile&#39;);

module.exports = {
    tasks: [
        {
            task: dejavuOptimizer,
            options: {
                files: {
                    &#39;src/myfile.js&#39;: &#39;dst/myfile.opt.js&#39;
                }
            }
        }
    ]
}</code></pre>
<h2>Works on</h2>
<ul>
<li>IE (6+)</li>
<li>Chrome (4+)</li>
<li>Safari (3+)</li>
<li>Firefox (3.6+)</li>
<li>Opera (9+)</li>
<li>Node.js and Rhino</li>
</ul>
<h2>Dependencies</h2>
<p>dejavu depends on <a href="https://github.com/mout/mout">mout</a>.
If you use the regular build, you don&#39;t need to worry because all functions used from mout are bundled for you.
If you use the AMD build, learn <a href="https://github.com/IndigoUnited/dejavu#taking-it-to-another-level">how</a> to setup your loader.
If you use dejavu on <code>node</code>, <code>npm</code> will take care of fetching everything for you.



</p>
<h2>License</h2>
<p>Released under the <a href="http://www.opensource.org/licenses/mit-license.php">MIT License</a>.</p>
